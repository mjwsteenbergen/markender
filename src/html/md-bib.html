<template id="md-bib">
    <h1>Bibliography</h1>
</template>
<script src="./bibtexParse.js"></script>
<script>
    // Refers to the "importer", which is index.html
    var thatDoc = document;
    // Refers to the "importee", which is src/hello-world.html
    var thisDoc =  (thatDoc._currentScript || thatDoc.currentScript).ownerDocument;
    // Gets content from <template>
    var mdbib = thisDoc.querySelector('#md-bib').content;

    class Bibliography extends HTMLElement {

        constructor() {
            super();
            this.searchElements = ["P", "H2"];
            this.format = null;
        }

        connectedCallback() {

            this.clone = document.importNode(mdbib, true);
            var bib = this;
            this.format = this.getAttribute("format") || "[{refnumber}]";
            this.src = this.getAttribute("src");

            document.addEventListener("DOMContentLoaded", function(event) {
                bib.startAlgorithm();
            });

            this.appendChild(this.clone);
            
        }

        startAlgorithm() {
            var httpRequest = new XMLHttpRequest();
            var bib = this;
            var once = false;
            httpRequest.onreadystatechange = function(e){
                if (httpRequest.status === 200 && httpRequest.responseText !== "") {
                    if(once) {
                        return;
                    }
                    once = true;
                    var bibtex = httpRequest.responseText;
                    var bibJ = bibtexParse.toJSON(bibtex);
                    bib.replaceText(bib.parentNode.parentNode, bibJ,  {}, 0);
                }
                else {
                    console.error(httpRequest.status);  
                }
            };
            httpRequest.open('GET', this.src, true);
            httpRequest.send();            
        }

        replaceText(node, bibtex, refs, reflength) {
            var bib = this;
            node.childNodes.forEach(function(element) {
                //Replace if text
                if (element.nodeName == "#text")
                {
                    var regex = /\[([^[]+)\]/g;
                    var output = regex.exec(element.textContent);
                    if(output != null)
                    {
                        bibtex.forEach(function(bibitem){
                            if(bibitem.citationKey == output[1]){
                                var ref = refs[bibitem.citationKey]; 

                                //If it is new
                                if (ref === undefined) {
                                    reflength = reflength + 1;
                                    refs[bibitem.citationKey] = reflength;
                                    bib.addBibItem(bibitem, reflength);                                 
                                }

                                element.parentNode.innerHTML = element.parentNode.innerHTML.replace("[" + output[1] + "]", bib.formatBib(bibitem, refs[bibitem.citationKey]));
                            }
                        });
                    }
                }

                //Continue down searchtree if not
                if (this.searchElements.includes(element.nodeName)) {
                    reflength = this.replaceText(element, bibtex, refs, reflength);    
                }
            }, this);  
            return reflength;      
        }

        formatBib(bibitem, refnumber)
        {
            var res = this.format.replace("{refnumber}", refnumber);
            return "<a href=\"" + "#bib-item-" + refnumber +"\">" + res + "</a>";
        }

        addBibItem(bibitem, refnumber)
        {
            var item = document.createElement('md-bib-item');
            item.setAttribute("bibitem", JSON.stringify(bibitem));
            item.setAttribute("refnumber", refnumber);

            this.appendChild(item);
        }
    }
    window.customElements.define('md-bib', Bibliography);
</script>